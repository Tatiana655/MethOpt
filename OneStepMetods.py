

#1)Решить задачу методом равномерного поиска и метод золотого сечения.
# Без вычисления производных применимы к унимодальным функциям.
# Где-то на каком-то интервале, уточняем интервал с требуемой точностью.
#Графики
#2)Сравниваются по числу обращений к функции, составить табличку с числом обращений 0.1,0.01,0.001 и число для заданной точности
#3)Формулу связи начального и конечного интервала неопределённости для методов. после заданного числа обращений к вычислению функции
#4)?: Что выгоднее в методе равномерного поиска. Делить 5 точками и несколько раз или сразу разделить на 25.

#x [0,1]
#требуемая точность
eps = 0.1
n = 3 #если меньше совсем плохо работает
#границы интервала
a = 0+10e-12#надо отступ
b = 1

def F(x):
    return 2*x + 1/x

#метод равномерного поиска
def UniSearch():
    a_new = a
    b_new = b
    print("Метод равномерного поиска")
    while (b_new - a_new > eps):
        h = (b_new-a_new)/n
        x = [a+h*i for i in range(n+1)]
        f_x = [F(i) for i in x]
        j = f_x.index(min(f_x))#индекс минимального элемента
        # новый интервал неопределённости j-1 j+1 *
        if j == 0:
            a_new = x[j]
        else:
            a_new = x[j-1]
        if j == len(x)-1:
            b_new = x[j]
        else:
            b_new = x[j + 1]
    print("Итоговый интервал: [", a_new, ";", b_new, "]")

#метод золотого сечения
def GoldenSelectionSearch():
    a_new = a
    b_new = b
    i = 0
    alf = (3-5 ** (1/2))/2
    while (b_new - a_new) > eps:
        lam_k = a_new + alf * (b_new - a_new)
        mu_k = a_new + b_new - lam_k
        print(i, " is ",lam_k, mu_k)
        i += 1
        if F(lam_k) < F(mu_k):
            b_new = mu_k
        else:
            a_new = lam_k
    print("Итоговый интервал: [", a_new, ";", b_new, "]")
